#pragma config(Sensor, in3,    Line1,          sensorLineFollower)
#pragma config(Sensor, in4,    Line2,          sensorLineFollower)
#pragma config(Sensor, in5,    Line3,          sensorLineFollower)
#pragma config(Sensor, in6,    Arm,            sensorPotentiometer)
#pragma config(Sensor, in7,    Ambient,        sensorReflection)
#pragma config(Sensor, dgtl1,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl6,  Bump,           sensorTouch)
#pragma config(Sensor, dgtl7,  ClawLimit,      sensorTouch)
#pragma config(Sensor, dgtl11, SonarIn,        sensorSONAR_cm)
#pragma config(Motor,  port2,           rightMotor,    tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port3,           leftMotor,     tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port4,           armMotor,      tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port5,           clawMotor,     tmotorServoContinuousRotation, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

void bothMotors(int value){
	motor[leftMotor] = value;
	motor[rightMotor] = value;
}
void drive(float length){//Tharf ad setja tad inn ad hann keyrir beint
	float value = length * 1650;
	bothMotors(100);
	Sleep(value);
	bothMotors(0);
}
void resetEncoders(){
	SensorValue[rightEncoder] = 0;
	SensorValue[leftEncoder] = 0;
}
void rotate(float gradurInn){

	float degrees = gradurInn;

	float distance = (1035*(degrees/360));

	resetEncoders();

	if(distance > 0){
		while(abs(SensorValue[rightEncoder]) < abs(distance)) // While the right encoder is less than distance:
	  {
	    motor[rightMotor] = -63;         //* Run both motors
	    motor[leftMotor]  = 63;         //* forward at half speed.
	    if(abs(SensorValue[rightEncoder]) > abs(SensorValue[leftEncoder])){
	    	while(abs(SensorValue[rightEncoder]) > abs(SensorValue[leftEncoder]) && abs(SensorValue[rightEncoder]) < abs(distance)){
	    		motor[leftMotor] = 70;
	    	}
	    }
	    else if(abs(SensorValue[rightEncoder]) < abs(SensorValue[leftEncoder])){
	    	while(abs(SensorValue[rightEncoder]) < abs(SensorValue[leftEncoder]) && abs(SensorValue[rightEncoder]) < abs(distance)){
	    		motor[rightMotor] = -70;
	    	}
	    }
	  }
	}
	else if (distance < 0){
		while(abs(SensorValue[leftEncoder]) < abs(distance)) // While the right encoder is less than distance:
	  {
	    motor[rightMotor] = 63;         // Run both motors
	    motor[leftMotor]  = -63;         //forward at half speed.

	    if(abs(SensorValue[rightEncoder]) > abs(SensorValue[leftEncoder])){
	    	while(abs(SensorValue[rightEncoder]) > abs(SensorValue[leftEncoder]) && abs(SensorValue[rightEncoder]) < abs(distance)){
	    		motor[leftMotor] = -70;
	    	}
	    }
	    else if(abs(SensorValue[rightEncoder]) < abs(SensorValue[leftEncoder])){
	    	while(abs(SensorValue[rightEncoder]) < abs(SensorValue[leftEncoder]) && abs(SensorValue[rightEncoder]) < abs(distance)){
	    		motor[rightMotor] = 70;
	    	}
	    }
	  }
	}
  bothMotors(0);
}

//1035 = heill hringur
//1650 = 1m afram

task main()
{

	while(SensorValue[Ambient] > 150){//lights on
		if(SensorValue[SonarIn] > 20  || SensorValue[SonarIn] == -1){//front is clear. If there is nothing in 10inches or nothing in the visible range
			bothMotors(-100);
		}
		else{
			rotate(22);
		}
		motor[clawMotor] = 63;
	}
	bothMotors(100);
	wait1Msec(1000);
}
